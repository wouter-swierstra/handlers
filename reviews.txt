Dear authors,

On behalf of the program committee of the 24th ACM SIGPLAN International
Conference on Functional Programming (ICFP 2019), I am delighted to inform
you that your submission #57 has been **conditionally accepted** to
appear in the conference.

       Title: A predicate transformer semantics for effects
     Authors: Wouter Swierstra (Utrecht University)
              Tim Baanen (Utrecht University)
        Site: https://icfp19.hotcrp.com/paper/57

Your paper is one of 39 conditionally accepted papers out of 119
submissions.

Reviews and comments are appended to this email. This material is also
available at the submissions site.

Please carefully read the reviews and comments, and check specifically for
**mandatory changes** that the program committee may have required. These
mandatory changes can appear inside one or more reviews and in comments.

The revision and the second-stage reviewing process take place as follows
(quoting the call for papers):

  After four weeks (**May 31, 2019**), the authors will provide a second
  submission. The second and final reviewing phase assesses whether the
  mandatory revisions have been adequately addressed by the authors and
  thereby determines the final accept/reject status of the paper. The
  intent and expectation is that the mandatory revisions can be addressed
  within four weeks and hence that conditionally accepted papers will in
  general be accepted in the second phase.

  The second submission should clearly identify how the mandatory
  revisions were addressed. To that end, the second submission must be
  accompanied by a cover letter mapping each mandatory revision request to
  specific parts of the paper. The cover letter will facilitate a quick
  second review, allowing for confirmation of final acceptance within two
  weeks (**June 14, 2019**). Conversely, the absence of a cover letter
  will be grounds for the paper's rejection.

Please note that all papers must adhere to appropriate format for
publication in PACMPL (see
http://sigplan.org/Resources/Author/#acmart-format for details and
templates). The appropriate LaTeX incantation should be

  \documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}

Please note that the page limit for the second submission is increased by
two pages: **27 pages plus bibliography for a regular paper or Functional
Pearl, 14 pages plus bibliography for an Experience Report**.

Fran√ßois Pottier <francois.pottier@inria.fr>
Program Chair, ICFP 2019

Review #57A
===========================================================================

Overall merit
-------------
A. Good paper. I will champion it at the PC meeting.

Reviewer expertise
------------------
Y. I am knowledgeable in the area, though not an expert.

Paper summary
-------------

This paper presents a connection between monadic effect and predicate
transformer semantics. The author(s) start with a definition of the
weakest precondition transformer for pure programs, before moving on
to discuss each effects. These include partiality (exceptions),
mutable state, non-determinism, and general recursion.

For each effect, the authors define a predicate transformer mapping a
postcondition to a precondition (usually named xxxPT) and lift it to
Kleisli morphisms (usually named wpxxx). Meanwhile, the authors define
function(s) to interpret/execute effectful programs, and finally prove
that the execution is sound with respect to the wp semantics.

In the penultimate section the authors also proposed a way to embed
holes into programs, and allow a program to be derived together with
its correctness proof.

Comments for author
-------------------

This is a well-structured paper that is, to me, very pleasant to
read. Things I like about this paper include:

* making a connection between predicate transformer semantics and
  various effects, where weakest precondition transformers for
  effectful programs can be defined in terms of the function "wp" for
  pure programs.

* Various concepts in predicate transformers emerge naturally in the context of the author's setting. These include
  - the "compositionality" property for sequential composition,
  - the need for predicate transformers to be monotonic,
  - two kinds of weakest precondition for non-determinism (which appear to correspond to angelic and demonic non-determinism),
  - loop invariant to reason about recursive programs, etc.

* Clever encoding of general recursive programs as (i : I) -> Free IO
  (O i), and partially finished programs as Free C R (I a).

While this paper may not have presented heavy-weight new discoveries,
the main contribution of this paper is making connections among
various existing theories --- on which, in my opinion, this paper did
a good job and is worth publishing.

-- minor comments --

* p1, l27. "deriving verified effectful programs their specifications"
-> "from" their specifications?

* p3, l142-145, when explaining pt: "These functions show how to lift
a predicate on the type a over an effectful computation returning
values of type a."  At this point the reader has not seen many
examples and it is hard to comprehend what is meant here. Can this be
explained better?

* p6. l292. "Here we describe the desired postcondition by introducing
a new datatype, Add... but there are many equivalent ways to formulate
the desired property."  If there are many ways to formulate this
property, why did you favor this one? (For example, does this approach
allow you to exploit pattern matching?)

* p9. l431, definition of wpState. The variable is bound once in
  "wpStatef P (x,i) = ..." and once again under "\i -> ...". Rename
  one of the "i" to avoid confusion.

* p10. l485. Can you be specific what P is? Is it relabelPost?

* p11, l512, definition of compositionality.  When read alone, the
reader might think that the "pt" here refers to the pt defined in p3,
l142. I guess what you meant here is that, for example, statePt,
defined as a fold over State b, is a special case of a more general
pt. Hope that can be made clearer.

* p22, l1073. Can you point out where (in the theorems presented in
  this paper) did you need Set:Set?


* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Review #57B
===========================================================================
* Updated: 2 May 2019 7:19:29am EDT

Overall merit
-------------
B. OK paper, but I will not champion it.

Reviewer expertise
------------------
Y. I am knowledgeable in the area, though not an expert.

Paper summary
-------------
This submission describes a methodology for type-theoretic reasoning
about computational effects defined by the programmer using free
monads. The development is conducted within the dependently-typed
language Agda, consisting of about 1,000 LoC.

The submission demonstrates this methodology using a sequence of
examples: exceptions, global state, backtracking/search, and fuelled
general recursion. It also demonstrates an
algebra-of-programming-style example adapted to this setting
(calculating the maximum of a list).

The format of the submission is of a literate Agda program (the
complete program is included in the supplementary material).

Comments for author
-------------------
Comments following response
-------------------------------------------

I have not changed my review following the response.

The response has a missing heading 'Reviewer 3'. If that's the case,
the only response to my review is:

> > In addition, even though the emphasis is on semantics, the
     predicate transformer semantics is never actually defined
     clearly, merely demonstrated through the examples. This is fine
     if the goal is to demonstrate a verification methodology. It
     isn't if the goal is to give semantics.

> By defining a map from programs (represented by a the Kleisli arrow
  of a free monad) to predicate transformers (of the form (b -> Set)
  -> (a -> Set)), we assign a predicate transformer semantics to these
  programs. Could you perhaps clarify in what sense this is not a
  semantics? We would be happy to fix this, but we don't quite
  understand the issue that is being raised here.

I still don't see a definition of a predicate transformer
semantics. Lines 137-144 suggest a type for the semantics function,
but only some of the examples actually match this type, whereas others
don't. For example, Partial does, but State doesn't.

Another point that I made in the review is that a semantics has
structure/properties not only for interpreting the raw terms, but also
for reasoning about it.  (comment starting in the words "497-547: This
observation seems important.")

As an analogy, an imperative programming language has an
interpretation using any monad-structure (object-map, return
functions, bind functions), even if this structure doesn't satisfy the
monad laws. (That's what Haskell's do-notation does.)

But if the laws don't hold, this interpretation is limited, and
nowadays may not form a semantics. Since the properties I highlighted
seems to hold for all the examples, perhaps they should be part of a
definition for wp/pt semantics.

Original review
---------------------


I recommend accepting this submission, but will not argue with expert
opinion to reject it.

Strengths:

* The submission deals with an important problem:

  We want to write programs that use effects, but also reason about
  them just like purely functional programs.

  One main challenge is how to conduct this reasoning along-side the
  program. Doing so is crucial for verification at scale.

* The submission is accessible, detailed, and clear.

  I am not an Agda expert, with only cursory experience, and I never
  felt lost while reading the submission.

* The development is systematic and thorough.

  While by no means complete, the development does cover a main simple
  examples of effects, so in the context of small- to medium-scale
  formalisation these examples cover a fair share of techniques.



Weaknesses:

* The contribution is unintentionally misleadingly phrased.

  This submission is not at all about the semantics of effects, as the
  title and abstract proclaim. It is really about how to reason about
  effects within dependent type theory. Much of the development in
  this submission is either irrelevant, or far from applicable, for
  semantics in other foundations (set theory in first-order logic or
  higher-order logic).

  In addition, even though the emphasis is on semantics, the predicate
  transformer semantics is never actually defined clearly, merely
  demonstrated through the examples. This is fine if the goal is to
  demonstrate a verification methodology. It isn't if the goal is to
  give semantics.

  This weakness can be easily fixed by simply changing the
  title/abstract/introduction.


Detailed comments
-----------------

8: consider explaining in what sense we will calculate programs, e.g.,
in the Bird-Meertens style.

44: typo: "we show how [] programs and specifications"

52: typo: "but the[] techniques translate readily"

131-133: I was confused by this paragraph until I got to lines 257
(the refinement characterisation for exceptions). Consider explaining
briefly what changes in the impure setting, perhaps after line 135:

  "In the impure setting, we will use different weakest precondition
  constructions, leading to a different characterisation of
  refinement. For example, in the presence of exceptions, raising the
  exception refines any other computation."

293: "there are many equivalent ways to formulate the desired
property": consider providing one or two more to substantiate this
claim.

298: typo: "predicate transform[er] _semantics_"

305: typo: "formulate [] the problem at hand"

354: in P's type, the predicate isn't dependently typed
     (P : a -> b -> Set) instead of (P : (x : a) -> b x -> Set)
     as one might expect following the discussion in 103-107.

     Consider explaining why we restrict attention to simply-typed
     predicates here.

376: "it is **only** by proving such soundness results that we can
ensure that the semantics is meaningful." As you do not give evidence
that this is the only way to ensure a meaningful semantics, consider
removing the words "it is only" and "that".

396: These smart constructors are called 'generic effects' in the
  algebraic effects literature (Plotkin and Power, 2003). You can define
  them in general:


  `generic op x = Step (op x) return`

  so `put = generic Put` and when `R op =` $\top$:

  `generic' op = generic op tt`

  so `get = generic' Get`.

497-547: This observation seems important. This discussion is close to
having a predicate transformer semantics, highlighting the crucial
properties wp and pt should satisfy: monotonicity and being an
algebra. Consider highlighting this discussion even more, perhaps in a
dedicated section, or earlier in the submission.

635: typo: "Once again, [we] can relate both"

635: What does 'again' refer to? Where did we previously relate these
two predicates to the list handler?

703: typo: "the correctness of this function[] amounts to"

768: typo: "defined in this style, such [as] the f91 function,"

828-832: What can we do in the direction of totality?

855-858: This paragraph doesn't seem to explain the code, merely
repeat it in words. Consider adding an example to show how to use I a
to mix specification and code.

994-996: There is nothing specific to state about this code apart from
the types. Consider explaining what's missing to allow us to write a
general version.

1051-1055: This paragraph is confusing to read without consulting the
source-code. Consider adding a few more details/excerpts from the
source-code explaining what kind of clutter is added.


Detailed stylistic suggestions
------------------------------

Feel free to ignore these!

153: It is strange to call the exception monad 'partiality', as
exceptional behaviour is decidable in the total setting, whereas
partial behaviour isn't. Consider renaming it to 'exceptions'.

159: consider explaining that $\perp$ is the empty type.

217-219: mustPT represents the choice to rule out failure
entirely. What other options do we have in this case?

271-275: Spec's definition forces separating the pre-condition and the
post-condition, for simplicity reasons. Consider mentioning this fact
at this point, rather than on section 8.

283: consider reminding the reader what K is, e.g. "This definition
uses the combinator $K\ a\ b = a$" (in general, consider introducing
the conventions you included in Prelude.agda).


* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Review #57C
===========================================================================
* Updated: 3 May 2019 10:34:10am EDT

Overall merit
-------------
B. OK paper, but I will not champion it.

Reviewer expertise
------------------
Y. I am knowledgeable in the area, though not an expert.

Paper summary
-------------
This article describes how to apply WP-style predicate transformers
and stepwise refinement -- two key concepts of provably-correct
software design -- to impure functional languages, using effect monads
(specifically, Free Monads), the theory of algebraic handlers, and
related notions.  The article is example-driven, treating partiality,
state, non-determinism and general recursion, all formalized in the
Agda proof assistant. It culminates in a treatment of stepwise
refinement, where proving and programming are integrated in the style
of Epigram, using a monadic representation of partial programs.

Comments for author
-------------------
It is a joy to read this paper; it serves as a great introduction to
the rapidly evolving research area, namely the integration of monadic
reasoning about effectful programming and interactive formal proof
development in type theory. The exposition is exceptionally clear; all
code examples are explained in detail, matching the elegance and
uniformity of the technical development.

Perhaps as a consequence of being led by the hand to this extent, the
reader is wondering where the hard work (and hence a major technical
contribution) is. Papers such as Ahman et al's "Dijkstra monads for
free" (POPL'17) have at least hinted at much of what's discussed here,
but are much heaver on the theory side. Thus, in order to go beyond a
tutorial, the paper should explain the Delta over Ahman a little
more. It appears the prime theoretical novelty is the connection to
refinement but also mention below some technical insights that - if
emphasized more, or earlier - would perhaps help articulate the
contributions more.

Overall, I'm at this stage tempted to recommend the paper as a
"functional pearl".

Strengths
---------

- exceptionally well organized presentation

- the treatment in Section 7 really takes the "step" in stepwise
refinement literally; I have rarely seen the internalization
("reflection") of SW development in type theory this elegantly

Weaknesses
----------

- the development is a little too example-driven: having seen the
various monads in action, a section explaining why/when this works
seems to be in place. Does the general framework of Dijkstra Monads
contain all the necessary structure? In the absence of such a
discussion (and of more complicated monads like exception,
probability,...), I'm wondering whether the monads treated here have
been purposefully selected....

- the discussion (line 1072-1077) mentions that the development uses
the unsound Set:Set axiom. This is as a bummer. The authors express
confidence that this can be corrected, but I would REALLY like to see
this done before publication, precisely because I expect this paper to
become rather popular: outsiders/newbies etc may easily be tempted to
discard this (and related) work based on this caveat. Once the
technical cleanup has been done, one can simply modify this one
sentence to say sth like "our proof development contains the necessary
universe stratifications but we have elided them in this paper for the
sake of readability" - readers will indeed appreciate not seeing
universe parameters etc all over the place!

Some technical comments and questions follow.
---------------------------------------------

- some recent presentations of FreeMonads use the coinductive version;
can the development be adapted accordingly (perhaps with wlp-style
transformers)? Or is the treatment of general recursion (also)
intended to convince the reader that nothing is lost if one sticks to
the inductive version?

- buried in the text are sentences that could almost verbatim be
copied to the introduction (or even abstract), to more clearly
articulate the key insights of the article. Examples are lines
527-523, the sentence spanning lines 842/3 ("By varying...") and the
insight in line 892/3 that P can be lifted from being a spec of a
computation to a spec over partial programs.

- line 997: can this proof be carried out in general or only on a
per-program/spec basis?

- to what extent can the development here be transferred to strongest
postcondition operators? The naive hope would be "in the expected
way", and this would be welcome: for example, symbolic executors for
separation logic prefer traversal in forward direction, since
otherwise, the issue of spooky disjunctions (Berdine APLAS'05) would
be even more severe. So it'd be good to see it worked out.


Minor comments:
---------------

line 313: the type of "add" here not an instantiation of the type that
as was promised in line 306 -- it lacks the "a" component inside the
"Partial"

line 445: it seems that not only the leaves are uniquely numbered by
the program that follows, but all nodes. Maybe also clarify that by
"size" you mean the number of leaves in lines 461 and 464?

line 485: identifier P is not specified here. And the next line says
that it's not obvious how to use the induction hypothesis to prove this goal.
It would help if you could show the Induction Hypothesis explicitly.

line 726/7: sometimes, one even does induction on "i"... (lower case)

line 824: the definition of putCorrect contains $x$ only once - perhaps
the RHS should read wpM (put x) instead of wpM put?

line 961: maybe replace \land by \to

line 984 and 985: the type of "Derivation" does not quite match the
one from line 935. Also, the clause for "Done" now uses ptM instead of
wpM? Consider adding some more explanations for these 2 changes.


* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Review #57D
===========================================================================

Overall merit
-------------
B. OK paper, but I will not champion it.

Reviewer expertise
------------------
X. I am an expert in the subject area of this paper.

Paper summary
-------------
# Summary

This paper investigates techniques for reasoning about effectful
programs in the dependently typed setting. In particular, the authors
show how to use predicate transformers (and pre-/postconditions) to
reason about the correctness of effectful code represented using free
monads in intensional type theory. The paper covers various standard
examples of computational effects, such as partiality, mutable state,
non-determinism, and general recursion, deriving for each of these
natural predicate transformer semantics, and demonstrating their use
on verifying small example programs. The paper also shows how to mix
code and specifications, so as to calculate correct-by-construction
effectful programs in a stepwise manner. The paper is also accompanied
by a constructive formalisation in the proof assistant Agda.

# Strengths

- The paper is clearly written and was a joy to read.

- The paper makes good use of the syntax of type theory for
  presenting examples and definitions cleanly and readably.

- The paper includes a novel use of predicate transformers, namely, using
  them to reason about the termination of potentially divergent code.

- The paper comes with an Agda formalisation of (most of the, see below)
  the definitions, examples, and theorems presented in the paper.

# Weaknesses

- The paper lacks significantly in discussion how (and that) the presented
  material relates to existing work in the literature.

- At places, the presented material lacks a unified story (see below).

- The part of stepwise refinement could make more use of being able
  to metaprogram effectful computations represented using free monads.

- The Agda formalisation could have been presented more conveniently
  to the reviewers, i.e., not merging all the different modules into
  a single file but rather keeping them in separate files for easier
  reading and typechecking.

# Overall evaluation

As I said above, the paper is well-written and joy to read. Unfortunately,
for a research paper, I found it significantly lacking in discussion and
explanations on how (and that) the presented material relates to existing
work in the literature, in particular, in pointing out which parts of it
are truly novel and which parts are about recasting existing results in
the particular setting the authors are working in (free monads in intensional
type theory). In particular, I believe that by taking some of these connections
seriously could improve the presentation in this paper in terms of providing
an even more general framework for predicate transformers based program
verification. I will discuss these shortcomings and opportunities for
improvements in more detail under Author Comments below.

In summary, I find it a little bit difficult to recommend this paper to be
accepted under the Full Papers category, based on the criticism outlined
above and detailed below. At the same time, saying that, I do think this
paper should be accepted under the Functional Pearls category, on the
condition that the criticism and comments in this review addressed. In
particular, I think this paper would serve as a neat and clean example
to the ICFP community of how to program and reason about effectful code
embedded in intensional type theory using free monads.

Comments for author
-------------------
# General recursion (novel contribution, not a weakness)

Before I get to what I believe are various weaknesses of this
paper, I wanted to point out that to my knowledge, this is the
first time predicate transformer semantics has been used to
reason about the non-divergence of potentially diverging code
in a dependently typed setting. Even the cutting edge of this
line of work, the F* language (connections with which are
discussed below), treats (non-)divergence specially and
separately from other uses of predicate transformer semantics.

# Relation to existing work (weakness)

## Algebraic effects

While you mention algebraic effects as a means for incorporating
computational effects in pure languages in the Introduction, you
never really come back to that connection with your work later on
(except when you discuss equations). However, the signatures you
consider later (partiality, mutable state, non-determinism) are
exactly the standard signatures of algebraic effects from the
literature (e.g., see [1]). It is just that for embedding their
work in intensional type theory, you use the standard method of
presenting signatures as containers and then considering the free
monad induced by the corresponding polynomial signature functor.

Further, what you call smart constructors in the paper, really
ought to be called generic effects [2] in the context of
programming with (algebraic) computational effects.

Please make the connection of your work with the literature of
algebraic effects more precise in a revised version of this paper.

[1] M. Hyland, G. Plotkin, J. Power: Combining effects: Sum and tensor,
    Theoretical Computer Science, vol 357, issues 1‚Äì3, pp 70-99, 2006.

[2] G. Plotkin, J. Power: Algebraic Operations and Generic Effects,
    Applied Categorical Structures, vol 11, issue 1, pp 69‚Äì94, 2003.

## Predicate transformers for partiality, state, and non-determinism

I believe that the kinds of weakest predicate transformer semantics
you define for partiality, mutable state, and non-determinism have all
recently appeared in the work of Ahman [3], who demonstrated how to
use effect handlers in the dependently typed setting to compute
weakest precondition semantics to standard algebraic effects.  In
particular, I see that Ahman also points out that there are two
natural ways how to lift a predicate on values to a predicate on
computation trees, analogously to your `allPT` and `anyPT`. The
difference with your work is that while Ahman worked in a calculus
with primitively built in algebraic effects and effect handlers, you
embed the same machinery in Agda using free monads and structural
recursion on the resulting computation trees.

Another piece of work the authors might be interested in is the
recent draft of Maillard et al [4] who also discuss and calculate
predicate transformer (and other kinds of) specification semantics
for effectful programs, including those arising from algebraic effects.

[3] D. Ahman: Handling Fibred Algebraic Effects. POPL 2018.

[4] K. Maillard et al: Dijkstra Monads for All, arXiv:1903.01237, 2019.

Just from pure interest, have the authors considered extending their
work to probabilistic programs, e.g., based on recent developments as
in [5], perhaps using some standard constructive representation of reals?

[5] B. Kaminski: Advanced Weakest Precondition Calculi for Probabilistic
    Programs, MSc thesis, PhD Thesis, 2019.

## Use of predicate transformer semantics in the F* language

Another piece of related work, that you mention only in passing, is
that of the dependently typed programming language F* and the use of
predicate transformer semantics in its effect system. However, unless
I am mistaken, I believe the connections between your work and the
work on F* are plentiful. Let me explain below.

First, `wpSpec` is exactly how in the F* language one defines a
pre- and postcondition style specifications as a syntactic sugar
on top of a corresponding predicate transformer semantics [6,7].
Further, the theorems about programs refining their specifications
(e.g., `correctness` on page 7) correspond exactly to the
verification conditions/logical implications that get proved when
the F* typechecker compares an inferred weakest precondition
to the user-provided type (when it is in pre-/postcondition style).

As an interesting sidenote, the above-mentioned draft of Maillard et
al [4] also observes that in fact there is a Galois connection between
the monotonic predicate transformer and pre-/postcondition
semantics, of whose one direction is given by `wpSpec`.

Second, I believe the various aspects of compositionality
(`compositionality`, `weakenPre`, `strengthenPost`) presented in
this paper directly correspond to the (sub-)typing of effectful
programs in F*, specifically, that of sequential composition.

Third, I believe the `Derivation` construction you introduce for
stepwise refinement internalises (at least at high level) F*'s
typing relation for effectful programs. In particular, the
compositionality and interactiveness provided by `Derivation`
looks to directly correspond to the kind of modularity one gets
from a type system for predicate transformer based typing of effects.

Fourth, while F* excels in verification due to the predicate
transformer based effect typing built into the language and
leveraging an SMT solver, I would have liked to see more discussion
and evaluation on how much burden the programmer will have when
this has all been embedded in intensional type theory as in this paper.

[6] N. Swamy et al: Dependent Types and Multi-Monadic Effects in F*, POPL 2016.

[7] D. Ahman et al: Dijkstra Monads for Free, POPL 2017.

# Towards a more unified story (weakness)

I mentioned earlier that one of the weaknesses of the paper is a lack
of a unified story between the different presented examples of effects,
namely, from the perspective of whether it is possible to package the
various considered predicate transformers up under a common interface.

Based on how predicate transformers are presented in [3], I believe
this kind of unified story could be quite easily achieved. In
particular, as in loc cit, the predicate transformers you define
(partiality, state, non-determinism) all amount to giving an algebra
on one's collection of propositions: for partiality and non-determinism
this is an algebra on `Set`, for state this is an algebra on `s -> Set`.
I believe this is one of those places where making the Curry-Howard
connection between functional programming and denotational semantics
precise would provide new insights into how to better structure code.

# Stepwise refinement and metaprogramming (small weakness)

Perhaps it is just me, but when I saw the free mixing of code and
specification promised in the Introduction, I expected a bit more than
I ended up seeing in Section 7. In addition to the very nice (!) way
of building correct-by-construction effectful programs interactively
using `Derivation`, I was somehow also expecting to see some
realisation of metaprogramming partial programs in the `M`
monad. Specifically, combinators for taking partial programs and
filling the holes (or creating new ones) in a way that is sound with
respect to the associated predicate transformer semantics. Of course
this is something I do not expect to be added in a quick revision of
the paper, but perhaps it is something the authors can consider in
future extensions of their work.

# Smaller comments

## Ordered monads

The `compositionality-left` and `compositionality-right` properties
of your predicate transformer semantics witness that such predicate
transformers in fact form ordered monads (in the sense of [8]). That
predicate transformers form a useful class of monads has been observed
in the work on the F* language, if not before in the folklore.

[8] S. Katsumata, T. Sato: Preorders on Monads and Coalgebraic Simulations,
    FoSSaCS 2013.

## Subset relation on `ND` computations

I was surprised that you reversed the direction of `nd1` and `nd2` in the
`\subseteq` relation definition on page 14. If `nd : ND a` is to be thought
of as a subset of `a`, then surely the relation should be defined the other
way around (and correspondingly the direction swapped in its uses below.).

Also, the change of direction in `refineAll` and `refineAny` is not very
surprising, because `wpAll` and `wpAny` amount to a big conjunction (forall)
and disjunction (exists), respectively.

However, I noticed that your Agda formalisation does not include the proofs of
`refineAll` and `refineAny` characterisations of the refinement relation.
Was this just an omission when packaging up the code for submission?

## Use of Agda's syntax

You should definitely briefly mention in the beginning of Section 2 that you
are using Agda's syntax to present the results of your work. This would be
useful to readers who have not worked with Agda beforehand. This would be
especially important if this paper gets reworked as a Functional Pearl.

## `Free` being a monad

On Page 2, you say that `Free` is a monad, but it is in fact `Free C R`
that is the monad. Could you please correct this inaccuracy.

## `Maybe`

On page 6, why did you suddenly switch to the `Maybe` monad from `Partial`?

## `soundness` for state

On page 9, shouldn't `soundness` be a bi-implication?

## `correctness` for state

On page 10, please state the induction hypothesis formally to aid the
reader who wants to understand the details without turning to Agda code.

## Proof-relevance of `Set`

On page 12, you should definitely remark that as `Set` is proof-relevant,
the equivalence relation between state-preconditions should really come
with coherence conditions, or be squashed to remove the need for them.

## Use of `\top`

To aid the reader, I suggest the authors use the syntactic synonym `1`
or `unit` for `\top` when one is talking about returning unit-values,
so as to better differentiate between what is logic and what is code.

## State laws

On page 12, `law2` is redundant, as it can be derived from `law1` and `law4`.

## `add` function

On page 15, please rename `add` to something else so that its name
does not clash with the `add` function from earlier.

## First (incomplete) definition of `Derivation`

On page 20, to aid the reader, please say that this incomplete definition
will be completed below once enough machinery has been developed.

Comments
===========================================================================

Response by Wouter Swierstra <w.s.swierstra@uu.nl>
---------------------------------------------------------------------------

We would like to thank the reviewers for their thoughtful feedback and
respond to a few of the points they raise.

* Reviewers 3 and 4 would like to see an more extensive discussion of
the relation between this work and recent work by Ahman and
others. Although we briefly mention the work on Dijkstra monads in the
related work section, we would happily extend this discussion. The
extensive feedback from Reviewer 4 is particularly valuable in this
respect.

* The fourth reviewer suggests rebranding the paper as a Pearl. In the
tradition of some previous ICFP papers on the topic, such as Gibbons
and Hinze's 'Just do it', we have chosen to illustrate the reasoning
techniques by means of examples rather than focus on the a more
theoretical presentation of these constructions. We can certainly make
the common theme in our constructions more explicit - defining
algebras over free monads to lift predicates; applying the
contravariant Set-valued Hom functor to map Kleisli morphisms to
predicate transformers -- in the conclusion. This is also in line with
the suggestion from Reviewer 2 to make these contributions more
explicit in the introduction.

We have responded to several specific issues raised by the reviewers
below.

### Reviewer 2

>  In addition, even though the emphasis is on semantics, the predicate
>  transformer semantics is never actually defined clearly, merely
>  demonstrated through the examples. This is fine if the goal is to
>  demonstrate a verification methodology. It isn't if the goal is to
>  give semantics.

By defining a map from programs (represented by a the Kleisli arrow of
a free monad) to predicate transformers (of the form (b -> Set) -> (a
-> Set)), we assign a predicate transformer semantics to these
programs. Could you perhaps clarify in what sense this is not a
semantics? We would be happy to fix this, but we don't quite
understand the issue that is being raised here.

> the discussion (line 1072-1077) mentions that the development uses
> the unsound Set:Set axiom. This is as a bummer.

The Set:Set axiom is mostly for convenience when working with
specifications and derivations (that are both too big for Set). We
have a working version of much of this development that does use
Agda's universe polymorphism and avoids Set:Set. For the sake of
presentation, we omitted this technical issue from the paper -- our
development does not fundamentally rely on this axiom in any way.

> some recent presentations of FreeMonads use the coinductive
> version; can the development be adapted accordingly (perhaps with
> wlp-style transformers)? Or is the treatment of general recursion
> (also) intended to convince the reader that nothing is lost if one
> sticks to the inductive version?

Although we do not have a proof, we believe that the treatment of
general recursion offers comparable expressive power. As the program
text is always finite, we favor a finite representation (making
recursion explicit when it is not accepted by the proof assistant)
over the (potentially infinite) coinductive version of free monads.

> line 997: can this proof be carried out in general or only on a
> per-program/spec basis?

This proof can be carried out in general: any program extracted from
the derivation starting from a specification, also satisfies this
specification.

> to what extent can the development here be transferred to
> strongest postcondition operators?

This isn't something we've looked at in this paper, but would
certainly be an interesting avenue for further research.

### Reviewer 4

> The Agda formalisation could have been presented more conveniently
> to the reviewers, i.e., not merging all the different modules into
> a single file but rather keeping them in separate files for easier
> reading and typechecking.

The formalisation is extracted directly from the paper, guaranteeing
the reviewers that 'what they read is what they get' (modulo
typesetting). Apologies if this results in a bit of a wait when type
checking the development.

> Just from pure interest, have the authors considered extending
> their work to probabilistic programs, e.g., based on recent
> developments as in [5], perhaps using some standard constructive
> representation of reals?

It is something we have considered. It would be particularly nice if
this can be shown to coincide with the work on probablistic refinement
by McIver and Morgan. But as this reviewer points out, doing so
requires the (non-trivial) construction of real numbers in type theory
and we have not done so yet.

> Based on how predicate transformers are presented in [3], I believe
> this kind of unified story could be quite easily achieved. In
> particular, as in loc cit, the predicate transformers you define
> (partiality, state, non-determinism) all amount to giving an
> algebra on one's collection of propositions: for partiality and
> non-determinism this is an algebra on Set, for state this is an
> algebra on s -> Set.

We believe this is part of the answer. Things get a bit more
interesting when considering some of the examples in the paper that
rely heavily on dependent types. When the Kleisli arrows exhibit a
dependency between the input and result, we believe simply using
Set-valued algebras will no longer suffice.

> I was somehow also expecting to see some realisation of
> metaprogramming partial programs in the M monad.

This is something we have considered. Much of the literature on
refinement provides quite explicit calculations -- much as the popular
equational reasoning style of verification contains a great deal of
redundant information. For now, we have chosen to stay close to this
presentation. A more scalable implementation should certainly hide
some of this information using tactics or metaprogramming.

Comment @A1 by Reviewer C
---------------------------------------------------------------------------
Comments added at the end of the discussion process:
--------------------------------------------------------------------------------------------------

Several reviewers felt that this submission should be reclassified as
a pearl, for two reasons: a) the exposition is very readable, and we
expect will appeal to a broad audience; b) the technical novelties are
not quite as substantial as required from full technical papers, and
are not quite as clearly articulated. Thus, the words "(Functional
Pearl)" in parentheses must be appended to the paper's title.

Thus, acceptance is ** conditional ** on making this formal
change. Furthermore, it is ** mandatory ** that the authors

i) add some text that sketches some common/general principles, as
suggested for example by reviewers D (see comments on "a more unified
story") and C ("do the general principles of Dijkstra monads suffice"
etc), and

ii) better put this contribution into the context of existing (recent)
work, to make clearer what's a novel contribution and what's a
rephrasing/adaptation of preexisting knowledge to the present setting.
